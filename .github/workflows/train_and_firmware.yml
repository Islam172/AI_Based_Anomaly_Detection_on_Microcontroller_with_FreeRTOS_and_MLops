name: train-and-firmware

on:
  push:
    branches: [ main ]
    # Optional: nur triggern wenn Python-Pipeline oder Dataset sich ändert
    paths:
      - 'Python_Pipeline/**'
      - 'frdmmcxn947_Project/**'
      - '.github/workflows/**'

  # Manuell starten im GitHub UI
  workflow_dispatch: {}

jobs:
  train_and_update_firmware:
    # Dein self-hosted Runner (Mac mit Python + MCUXpresso + Board)
    runs-on: self-hosted

    env:
      PYTHON_DIR: Python_Pipeline
      FIRMWARE_DIR: frdmmcxn947_Project         
      VENV_DIR: .venv_ci             # virtuelles Env NUR für CI
      LATEST_ARTIFACT_DIR: ''

    steps:
      # --- 1) Code holen ---
      - name: Checkout repository
        uses: actions/checkout@v4

      # --- 2) Python-Version bereitstellen (falls nötig) ---
      # Funktioniert auch auf self-hosted, wenn die Version installiert ist.
      - name: Use system Python
        shell: bash
        run: |
          python3 --version


      # --- 3) Virtuelle Umgebung + Dependencies ---
      - name: Create venv and install dependencies
        working-directory: ${{ env.PYTHON_DIR }}
        shell: bash
        run: |
          python3 -m venv ${{ env.VENV_DIR }}
          source ${{ env.VENV_DIR }}/bin/activate
          pip install --upgrade pip
          pip install -r requirements.txt

      # --- 4) Trainings-Pipeline ausführen ---
      # Ruft deine src/pipeline/training_pipeline.py auf
      - name: Run training pipeline
        working-directory: ${{ env.PYTHON_DIR }}
        shell: bash
        run: |
          source ${{ env.VENV_DIR }}/bin/activate
          python3 main.py

      # --- 5) Neuesten Artifacts-Ordner finden ---
      # artifacts/<timestamp> mit größtem Timestamp
      - name: Find newest artifact directory
        id: find_latest
        shell: bash
        working-directory: ${{ env.PYTHON_DIR }}
        run: |
          latest=$(ls -1d artifacts/* | sort -r | head -n 1)
          echo "LATEST_ARTIFACT_DIR=$latest" >> $GITHUB_ENV
          echo "Latest artifact dir: $latest"

      # --- 6) axis_scaler.h + model.h + model_info.json ins Firmware-Projekt kopieren ---
      # Passe die Pfade im Firmware-Projekt an deine Struktur an!
      - name: Copy headers into Firmware project
        shell: bash
        run: |
          # Quelle (Python-Pipeline)
          SRC_AXIS_SCALER="${{ env.PYTHON_DIR }}/${{ env.LATEST_ARTIFACT_DIR }}/feature_extraction/axis_scaler.h"
          SRC_MODEL_H="${{ env.PYTHON_DIR }}/${{ env.LATEST_ARTIFACT_DIR }}/model_trainer/model.h"

          # Ziel (MCUXpresso-Projekt) :
          AXIS_SCALER_DIR="${{ env.FIRMWARE_DIR }}/source/inf-eng/emlearn"
          MODEL_DIR="${{ env.FIRMWARE_DIR }}/source/models/emlearn"
          

          cp "$SRC_AXIS_SCALER" "$AXIS_SCALER_DIR/axis_scaler.h"
          cp "$SRC_MODEL_H"     "$MODEL_DIR/model.h"
          

          echo "Copied:"
          

      # --- 7) Firmware builden (MCUXpresso Headless) ---
      # Dieser Teil ist ein Template – du musst den Pfad zur mcuxpresso-CLI
      # und den Projekt-Namen an dein Setup anpassen.
      - name: Build firmware (MCUXpresso headless)
        shell: bash
        run: |
         MCUXPRESSO_CLI="/Applications/MCUXpressoIDE_25.6.136/ide/MCUXpressoIDE.app/Contents/MacOS/mcuxpressoide"
         PROJECT_NAME="frdmmcxn947_ml_state_monitor"
         WORKSPACE_PATH="$PWD/mcux_workspace"
     
         echo "Creating workspace directory: $WORKSPACE_PATH"
         mkdir -p "$WORKSPACE_PATH"
     
         echo "Running headless build for: $PROJECT_NAME"
         set +e   # <-- erlauben, dass mcuxpresso exit 1 liefert
     
         "$MCUXPRESSO_CLI" \
           --launcher.suppressErrors \
           -nosplash \
           -application org.eclipse.cdt.managedbuilder.core.headlessbuild \
           -no-indexer \
           -data "$WORKSPACE_PATH" \
           -import "$PWD/${{ env.FIRMWARE_DIR }}" \
           -build "$PROJECT_NAME"
     
         BUILD_EXIT=$?
         set -e
     
         # Prüfen ob AXF erzeugt wurde
         AXF_FILE="$WORKSPACE_PATH/$PROJECT_NAME/Debug/$PROJECT_NAME.axf"
     
         if [ -f "$AXF_FILE" ]; then
             echo "AXF successfully built: $AXF_FILE"
             echo "Ignoring MCUXpresso exit code: $BUILD_EXIT"
         else
             echo "ERROR: AXF file not found. Build truly failed."
             exit 1
         fi


      

      # --- 8) OPTIONAL: Firmware flashen ---
      - name: Flash firmware to board (optional)
        if: false          # <- auf true setzen, wenn du automatisch flashen willst
        shell: bash
        env:
          PROJECT_NAME: frdmmcxn947_ml_state_monitor
        run: |
          # Pfad zum Redlink-Flasher (MAC)
          CRT_EMU="/Applications/LinkServer_25.6.131/binaries/crt_emu_cm_redlink"
      
          # Workspace, der im vorherigen Build-Step angelegt wurde
          WORKSPACE_PATH="$PWD/mcux_workspace"
      
          # AXF-Datei des Projekts
          AXF_FILE="$WORKSPACE_PATH/$PROJECT_NAME/Debug/$PROJECT_NAME.axf"
      
          echo "Using AXF: $AXF_FILE"
      
          if [ ! -f "$AXF_FILE" ]; then
            echo "ERROR: AXF file not found: $AXF_FILE"
            exit 1
          fi
      
          echo "Flashing firmware to MCXN947..."
      
          "$CRT_EMU" \
            -flash-load-exec "$AXF_FILE" \
            -p MCXN947 \
            -vendor NXP \
            -reset hard || {
              echo "Flashing failed"
              exit 1
            }
      
          echo "Flashing successful!"
      
